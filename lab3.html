<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    /*background-color: #fee9cc;*/
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Lab 3 User Environments</title>

</head>
<body>
<h1>Lab 3 User Environments</h1>

<p><strong>YANG Weikun 1100012442</strong></p>

<p>PartA: 30th September 2013, 17:00 UTC+0800<br/>
PartB: 4th October 2013, 22:30 UTC+0800</p>

<hr />

<h2>Ex.1 Allocating the Environments Array</h2>

<p>In <code>kern/pmap.c:mem_init()</code>, add those two lines:</p>

<pre><code>envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
boot_map_region(kern_pgdir, UENVS, 
    ROUNDUP(NENV * sizeof(struct Env), PGSIZE), 
    PADDR(envs), PTE_U | PTE_P);
</code></pre>

<p>I actually modified more code in <code>mem_init()</code>:</p>

<pre><code>boot_map_region(kern_pgdir, KERNBASE, npages*PGSIZE, 0, PTE_W);
</code></pre>

<p>to map only available memory, so accessing above 128MB (default RAM size of QEMU) will cause a page fault instead of obscure behaviours. And in <code>check_kern_pgdir()</code> to suit the change:</p>

<pre><code>// for (i = 0; i &lt; NPDENTRIES; i++) 
for (i = 0; i &lt; npages / NPTENTRIES; i++) 
</code></pre>

<p><strong><em>Note: from this point, I will try not to quote too much code, for obvious reasons</em></strong></p>

<ul>
<li><strong>Quoting too much code ruins your report! People don't really care about your exact implementation, they want an general description of your design, something you can't steal. Anyone want to see the code, they head for your code directly.</strong></li>
<li><strong>Isn't it very nice to practice English writing on technical issues?</strong></li>
</ul>


<p>The report becomes considerably shorter but nevertheless expressive.</p>

<hr />

<h2>Ex.2 Creating and Running Environments</h2>

<p>In <code>env_init()</code>, memory occupied by <code>envs</code> is wiped clean, then all <code>struct Env</code>s are linked.</p>

<p>In <code>env_setup_vm()</code>, first a physical page is allocated for the <code>Env</code>'s page directory. Page directory entries for VA above <code>UTOP</code> is copied from <code>kern_pgdir</code>, the rest is unmapped. Then the reference count is incremented.</p>

<p>As for <code>region_alloc()</code>, that allocates memory for user ELF image, with user read/write permission. <code>va</code> and <code>len</code> are rounded appropriately.</p>

<p>Moving on to <code>load_icode()</code>. We must parse the ELF structure, and load appropriate segments into the <code>Env</code>'s VA, and reserve wiped space if necessary. Then we copy the ELF's entry point to <code>eip</code> of the <code>Env</code>'s trap frame. Finally we  allocate 1 page for the program's stack. I used <code>lcr3</code> to switch the page directories, so that I can access user VA directly.</p>

<p>Next we have <code>env_create()</code> to sum up all the preparation.</p>

<p>Finally the <code>env_run()</code> that fall back to user program.</p>

<p>Now our <code>joe</code> should be able to drop to user program. See my debug session: User program was loaded at <code>0x800020</code>, call chain is like this (some omitted):</p>

<ul>
<li><code>0x80002c call libmain&lt;0x800060&gt;</code>

<ul>
<li><code>0x80008d call umain&lt;0x800034&gt;</code>

<ul>
<li><code>0x800041 call cprintf&lt;0x800171&gt;</code>

<ul>
<li><code>0x80018c call vcprintf&lt;0x80010c&gt;</code>

<ul>
<li><code>0x800149 call vprintfmt&lt;0x80035a&gt;</code>

<ul>
<li><code>0x800fb5 sys_cputs</code>

<ul>
<li><code>800f4c syscall</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><code>syscall</code> emitted a instruction <code>int $T_SYSCALL</code> at <code>0x800f69</code>, then our CPU went into <em>'double fault'</em>, without a proper handler, then into <em>'triple fault'</em> and halts.</p>

<hr />

<h2>Ex.3 Handling Interrupts and Exceptions</h2>

<p>Book reading: done.</p>

<p>In short, how x86 processors handle interrupts is fairly complex. Intel gave interrupt, exceptions, faults and traps a common name <em>'Protected Control Transfer'</em> when such transfer happened in user mode. Whatever the cause, the processor uses two important data structures namely <strong>Interrupt Descriptor Table</strong> and <strong>Task Segment Selector</strong>: when an interrupt occurs(including traps etc.), the CPU locates the interrupt descriptor using interrupt number as a subscript to the <em>IDT</em>, checks permissions then saves machine state (<code>SS</code>, <code>ESP</code>, <code>EIP</code> etc.) to the location specified by <em>TSS</em>, and jump to code pointed by the corresponding interrupt descriptor.</p>

<p>When the interrupt occurred in kernel mode or inside an interrupt handler, the processor does pretty much the same (without changing to the stack specified by <em>TSS</em>).</p>

<hr />

<h2>Ex.4 Setting Up the IDT</h2>

<p>I've written a little python script, to do the messy work automatically:</p>

<ol>
<li>generate trap vectors in <code>kern/trapentry.S</code> using <code>kern/trapentry.tmpl</code> as template.</li>
<li>setup IDT entries in 'kern/trap.c' using <code>kern/trap.c.tmpl</code> as template.</li>
</ol>


<p>This part of the logic is written in <code>kern/Makefrag</code>. Following instruction on MIT's page, we now have the IDT working.</p>

<p>Later I found a alternative way which is pretty elegant as well. A short description:</p>

<ul>
<li>Store the interrupt handlers as an array of function pointers, by mixing <code>.data</code> and <code>.text</code> assembler directives in the handler-generating macro.</li>
<li>Use the macro to create the handlers, not to leave the unused slots so that the array stays continuous.</li>
<li>In <code>trap.c</code>, use a <code>for</code> loop to install the IDT.</li>
</ul>


<h3>Q&amp;A</h3>

<ol>
<li><em>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</em>

<ul>
<li>if all interrupts were first handled in the same place, there will be no way of telling them part. In the current implementation we relied on the first level handler <code>_alltraps</code> to store the interrupt number on stack, then call the generic handler <code>trap</code>.</li>
<li>Isn't it nice to have all interrupts be dispatched in a same place? So that  the design becomes very clear and your code less messy.</li>
</ul>
</li>
<li><em>Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?</em>

<ul>
<li>Nope, it happened just like that. Initiating a interrupt requires the <em>'Current Privilege Level'</em> be less or equal to the interrupt gate's <em>'Descriptor Privilege Level'</em>. In <code>kern/trap.c</code> we defined the all interrupt gates' DPL to be 0 (only accessible in kernel mode, by <code>int</code> instruction), except for the <code>breakpoint</code> gate. So issuing <code>int $14</code> will cause general protection fault instead of the requested page fault.</li>
<li>If the kernel allows arbitrary use of interrupt gates and trap gates, regardless of CPL, it would be very easy for user programs to disturb the kernel (for example, by repeatedly issuing divide by zero exception through <code>int $0</code>). The kernel must forbid such actions.</li>
</ul>
</li>
</ol>


<hr />

<h2>Ex.5 Handling Page Faults</h2>

<p>In <code>kern/trap.c trap_dispatch()</code> I used <code>switch-case</code> to dispatch traps. Trap number is stored in <code>tf-&gt;tf_trapno</code>, for the case <code>T_PGFLT</code> we just need to call <code>page_fault_handler(tf)</code>.</p>

<p>The privilege level that the trap's initiator was in, is stored in the last 2 bits of <code>CS</code> segment selector. If the page fault was from the kernel (privilege level 0), we will print the trap-frame then panic. Otherwise the fault must be from user (privilege level 3), we handle this by printing the trap-frame then destroy the current environment.</p>

<hr />

<h2>Ex.6 The Breakpoint Exception</h2>

<p>This one is dead simple: add a <code>case</code> in <code>trap_dispatch()</code> for <code>T_BRKPT</code>, then invoke <code>monitor(tf)</code>.</p>

<h3>Q&amp;A</h3>

<ol>
<li><em>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</em>

<ul>
<li>see the answer for question 1, ex. 4. Currently <code>T_BRKPT</code> and <code>T_SYSCALL</code> are the only two interrupts that can be invoked by <code>int</code> instruction in user mode, for their <em>DPL</em> being 3. If the <em>DPL</em> is 0, then <code>int $T_BRKPT</code> will cause a general protection interrupt.</li>
</ul>
</li>
<li><em>What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?</em>

<ul>
<li>I believe my answer for question 2, ex.4 is good for this one as well. The kernel must punish those user programs who abuse the <code>int</code> software interrupt instruction to create inconsistencies, by killing them right away without mercy.</li>
</ul>
</li>
</ol>


<hr />

<h2>Challenge</h2>

<h3>Break/Continue/Single-Stepping, and a general debugger for user programs</h3>

<p>later.</p>

<hr />

<h2>Ex.7 System Calls</h2>

<p>In function <code>syscall()</code> in <code>kern/syscall.c</code>, another <code>switch-case is</code> used to dispatch the system calls according to <code>syscallno</code>. For every case we convert and pass required arguments, then delegate return values if any. <code>-E_INVAL</code> is returned if a non-existing system call is requested.</p>

<hr />

<h2>Challenge</h2>

<h3>Fast system call by sysenter/sysexit instructions.</h3>

<p>later.</p>

<hr />

<h2>Ex.8 User-mode startup</h2>

<p>When we don't know where to add code, better search <code>// LAB 3: Your code here</code>. So convenient!</p>

<p>First we figure out our env_id by calling user mode helper <code>sys_getenvid()</code>, then modify <code>thisenv</code> accordingly.</p>

<hr />

<h2>Ex.9/10 Memory Protection</h2>

<p>First part: kernel mode page fault is already handled in Ex.5.
Second part: sanity checking of user's arguments.</p>

<p>In <code>kern/pmap.c</code>, we must implement <code>user_mem_check()</code> to verify the existence and permission of a range of memory in user space. <code>user_mem_assert()</code> will destroy the user <code>Env</code> if memory access violates. <code>debuginfo_eip</code> and various system calls use the sanity checks as well.</p>
</body>
</html>